To help gain a better understanding of the physical system, various aspects of the hovercrafts' control and motion were qualitatively and quantitatively measured and analyzed. These measurements were employed as part of the process of supplying the vehicles with autonomous intelligence. This section of the report provides details about the following parameters: maximum speed, stopping distance, PWM cycles vs actual speed and payload vs actual speed.

\subsection{Distance}
A first step in many subsequent calculations was the determination of the distance between the hovercrafts and an oncoming object. It was decided that a sonar could be used to calculate this distance. The sonar was calibrated to report the distance between itself and an object in inches.

\subsection{Speed}
To calculate the speed of the craft, sonar readings were sampled at a set interval.  The change in the values of theses readings (with respect to time) produced a reliable source means for determining the speed of the vehicles.  The most challenging aspect of this approach was accurately sampling the sonar readings at set intervals.  The procedure for sampling the sonar at set intervals in an accurate manner is as follows:

The clock speed is at 8 MHz.  Timer 2, which is an 8 bit timer, was used. The prescaler was set to a factor of 1024, resulting in a frequency reduction to 8 000 000/1024 = 7812.5Hz. A counter increased at this frequency, and thus  overflowed every 256 ticks. By setting the TOIE2 bit in the TIMSK2 register, an interrupt was enabled on each overflow. This resulted in the register overflowing 30 times per second (7812.5 / 256). In the overflow register, a counter existed that increased each time the interrupt was fired, thus maintaining a count of the cumulative overflows.  Further, a variable was maintained to represent the desired amount of time between sonar firings. This variable was set at 2, so that the sonar would fire every 2 seconds. In the overflow interrupt, an if statement checked to see if the counter had overflowed enough times for 2 seconds to pass. If this conditional returned true, the counter was reset to zero and the sonar triggered. This if statement also contained the code to calculate the current speed. An array of size two was also created that maintains the current sonar reading and the previous sonar reading. The difference was calculated between these readings and divided by two. The speed was calculated using decimal numbers. This reduced the accuracy, but saved on space from using the floating point numbers. The output was finally sent to UART.

While testing the sonar, it was noticed that significant of noise was generated when the sonar read the value of new objects. This had a significant impact on the quality of the final speed measurement generated. To account for this, we created a static array of 5 integers which holds the values of the 5 most recent speed calculations. The final speed, used by the vehicle's components, is the average of these 5 speed calculations. We found that this modification greatly improved the accuracy in the trend of speed calculations output to uart. We believe that we may be able to do even better. By eliminating values that seem to be complete noise, the average speed calculations will also be more accurate because they don't include such outliers. We hope to have this additional logic incorporated into milestone 3.

\lstset{language=c}
%\lstset{commentstyle=\textit}
\begin{lstlisting}[frame=trbl]{}
#define OVERFLOW_LIMIT 30
#define TIME_BETWEEN_SONAR 2

volatile int overflowCounter  = 0;
volatile uint8_t timeInterval = 0;
volatile uint8_t distances[2] = {0, 0};
volatile bool isSecondReading = false;

volatile char uartBuf[255];
volatile int  uartLen = 0;

void 
speedCalcInit()
{
    // Set TIMER 2 to CTC mode.
    TCCR2A &= ~(1 < < WGM20);
    TCCR2A |=(1 < < WGM21);
    TCCR2B &= ~(1< < WGM22);

    // Set clock prescaler to 1024
    TCCR2B |= (1 < < CS22) | (1 < < CS21) | (1 < < CS20);

    // Set OC2A on compare match
    TCCR2A |= (1 < < COM2A1) | (1 < < COM2A0);

    // Enable interrupt on compare match
    TIMSK2 |= (1 < < OCIE2A);

    // Enable overflow interrupt
    TIMSK2 |= (1 < < TOIE2);

    // Set OCR2A to the highest possible value.
    OCR2A = 0xFF;
}

/**
 * Compare match interrupt service routine.
 */
ISR(TIMER2_COMPA_vect)
{

}

/**
 * Timer 2 overflow interrupt service routine.
 */
ISR(TIMER2_OVF_vect)
{
    if (++overflowCounter >= OVERFLOW_LIMIT) {
        ++timeInterval;
    }

    if (timeInterval >= TIME_BETWEEN_SONAR) {
        trigger_sonar();
        timeInterval = 0;
        overflowCounter = 0;

        if (!isSecondReading) {
            distances[0] = read_distance();
            isSecondReading = true;
        } else {
            distances[1] = read_distance();

            uartLen = sprintf((char *)uartBuf, "%d\r\n", distances[0]);
            uart_write((uint8_t *)uartBuf, uartLen);
            uartLen = sprintf((char *)uartBuf, "%d\r\n", distances[1]);
            uart_write((uint8_t *)uartBuf, uartLen);

            // calcluate velocity
            int velocity = (distances[1] - distances[0])/TIME_BETWEEN_SONAR;
            uartLen = sprintf((char *)uartBuf, "vel: %d\r\n", velocity);
            uart_write((uint8_t *)uartBuf, uartLen);

            distances[0] = distances[1];
        }
    }
}
\end{lstlisting}

\subsection{Turning Radius}
The turning of our craft is very small, almost in place. To get this effect, we have two motors that are on either side of the centre. When turning at full speed, one motor will me moving forwards, while the other is spinning backwards. Table \ref{turningRadius} shows the speeds and corresponding PWMs. 

\begin{table}
\caption{Hovercraft Turning Radius}
\begin{center}
\begin{tabular}{ c c }
  Speed (inch/sec) & PWM \\
  \hline
  5 & 255 \\
  3 & 245 \\
\end{tabular}
\end{center}
\label{turningRadius}
\end{table}

Once we were accurately able to calculate the speed of the craft it was simple to calculate the stopping distance. We set up a test area in the a hallway with a tape measurer along the wall. We had two different stopping tests. In the first, we would drive the robot down the hall. Once the robot steadily reached the testing speed, we would allow the joystick to snap back into the center 'resting' position and measure the distance the robot traveled.

\subsubsection{`Resting' Stop}
\begin{table}
\caption{Stopping Distances (to rest)}
\begin{center}
\begin{tabular}{ c c }
  Speed (inch/sec) & Stopping Distance (meters) \\
  \hline
  5 & 3 \\
  3 & 2.5 \\
\end{tabular}
\end{center}
\label{restingTable}
\end{table}

The other way that the robot could stop, was by reversing both motors. We would have the same initial set up with a tape measurer in the hall way, but once the craft reached the `testing' speed, we would then pull the joystick into maximum reverse position. For this calculation we were also required to record the time it took the craft to stop. The reason we needed to do this, was so that when we are driving the robot autonomously, we are able to calculate the duration that the motors must run in reverse to come to a complete stand still with out traveling backwards.

\subsubsection{`Reverse' Stop}
\begin{table}
\caption{Stopping Distances (from Reverse)}
\begin{center}
\begin{tabular}{ c c }
  Speed (inch/sec) & Stopping Distance (meters) \\
  \hline
  5 & 1.3 \\
  3 & 0.90 \\
\end{tabular}
\end{center}
\label{reverseTable}
\end{table}

\subsection{Payload}
All of the above measurements are recorded with only the required components placed on the hovercraft, as well as the additional components required to eliminate rotational spin. The following table, describes how the speed of the craft changes with the amount of excess weight is added to the craft. All of the additional weight was distributed evenly around the chassis to minimize the rotational spin. The table also describes how the speed changes when the motors are receiving full (255) PWM.
\begin{table}
\caption{Hovercraft Supported Weight}
\begin{center}
\begin{tabular}{ c c }
  Additional Weight (grams) & Speed (meters/sec) \\
  \hline
  100 & 4 \\
  200 & 3 \\
  300 & 1 \\
  400 & stopped \\
\end{tabular}
\end{center}
\label{weightTable}
\end{table}
