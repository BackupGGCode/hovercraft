This project, the construction of two autonomous and coordinated hovercrafts, has served as a learning experience for many problem domains including embedded software, electrical engineering, control theory, and more.  This team's primary interests were those revolving around software problems - concerns such as inter-hovercraft communication, onboard software debugging, control synchronization, code efficiency and autonomous intelligence (for example the implementation of a PID controller).  Unfortunately, the team's tendencies and strengths in the software domain, and lack of knowledge in the hardware domain, was likely a main factor in the less-than-perfect project implementation.  

Arguably, the largest problem that impeded the progress of the project was the unwanted movement found when testing each of the hovercraft prototypes.  Factors such as rotational torque, uneven airflow from the base and skirt, nonuniform distribution of weight across the body, and unbalanced thrust from each of the propellers all contributed to unwanted movement to a hovercraft that should have been stationary.  Without this most basic level of control over the physical system, implementing a truly effective PID controller and communication scheme among master and slave hovercrafts was next to impossible.  Another problem that plagued the entire endeavor was a general lack of understanding of electronics and electrical engineering principles.  Questionable wiring and soldering, as well as unclear usage and application of several common electrical components (H-bridges, resistors, measurement equipment, etc) made many processes more painful than they should have.  Inexperience with these components and principles lead to hours of confusion, an example is when the team believed they had made a wiring mistake, or were given a faulty H-bridge, when the problem was simply that a heat-sink had to be attached, as the H-bridge was overheating. That said, the project did advance satisfactorily in many other areas.  

Communications were one of the most interesting aspects of the project.  Hovercraft-to-base communications was straightforward and was implemented in milestone 1.  Hovercraft-to-hovercraft communications were somewhat more difficult.  Successful communication in this environment required a higher degree of fault-tolerance and automation. Once the user initiates both vehicles, he or she no longer has any further control of the physical system.  The approach taken, a state diagram and protocol whereby the leading vehicle acted as the master while the following vehicle acted as a passive slave, seemed to be the most plausible and manageable solution.  In fact, 3-way communication needed to occur.  The hovercraft-to-hovercraft traffic was needed to synchronize movement among the vehicles, while master hovercraft-to-base was also required to provide monitoring diagnostic information.  While this scheme at first appears complicated, designing a well thought out state diagram and carefully implementing it resulted in satisfactory behavior.  

Another area of interest was code efficiency and correctness.  Very soon into the project, it was discovered that traditional debugging techniques simply aren't adequate for an embedded system.  An approach as elementary as inserting printf calls throughout the code was unacceptable as that function call takes too much time to execute.  Instead of a full printf call, a much simpler function was used to print a small number of characters to the microcontroller's UART I/O connection.  This form of debugging was acceptable but there were some unnecessary complexities involved including the UART support code, radio communication code, and various interrupt handlers.  An alternative that was superior for many debugging tasks was the JTAG onboard debugging option.  A JTAG unit was connected directly to the JTAG I/O connection on the Atmel microcontroller, allowing the CPU's registers to be examined directly.  This particular embedded environment is also a real-time system.  As such, the most complicated dimension of the code, by far, is meeting the stringent timing demands of the system.  The most productive way to combat this problem seemed to be incorporating a realtime operating system to help automative much of the timing logic of tasks.  The RTOS used was the in-house RTOS developed by previous students in the course.  

The following are recommendations for future students who plan on undertaking a similar project.  First, be sure to acquire a solid understanding of general electronics, wiring and measurement techniques, and schematic diagrams.  Developing the software for a system such as this is but a small fraction of the overall process required.  In fact, it may be wise to ensure that at least one team member has a significant background in electrical engineering concepts. Next, take the proper time to understand the programming environment.  Programming at such a low level is different for many reasons, a few being severely reduced hardware resources, an alternate standard C library and assembly instruction set, significant interaction at the hardware interface level, and developing an alternate way to debug and test code.  Finally, be sure to take a pragmatic approach to constructing the physical system.  Devise miniature experiments to test theories about how the system will behave.  Choose functionality over aesthetics always. Thoroughly test each component independently. Choose simplicity over complexity.  Solve as many problems as possible at the hardware level instead of delegating it to software.  For example, PID controllers are difficult enough to get right with a well behaved physical system.  Tuning a PID controller to a sporadic and unpredictable physical system is next to impossible. Document everything.  Following these recommendations should help to streamline the construction process and will serve to help one get the most of a course as diverse and challenging as this one. 